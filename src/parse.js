
// TODO: add string escaping
var Parse = (function() {
  /**
   * The Lexer takes the original expression string and returns an array of tokens parsed from that string
   */
  function Lexer() {

  }
  Lexer.prototype.lex = function(text) {
    this.index = 0;
    this.text = text;
    this.tokens = [];

    while (this.index < text.length) {
      var ch = text.charAt(this.index);
      if (this.isNumber_(ch) ||
          (ch === '.' && this.isNumber_(this.peek()))) {
        this.readNumber_();
      } else if (this.isString_(ch)) {
        this.readString_();
      } else if (ch === '[' || ch === ']' || ch === ',' ||
                 ch === '{' || ch === '}' || ch === ':') {
        this.tokens.push({
          type: AST.Literal,
          text: ch
        });
        this.index++;
      } else if (this.isIdentifier_(ch)) {
        this.readIdentifier_();
      } else if (this.isWhitespace_(ch)) {
        this.index++;
      } else {
        throw new Error('Unexpected next character ' + ch);
      }
    }

    return this.tokens;
  };

  Lexer.prototype.peek = function() {
    return this.index + 1 < this.text.length ? this.text.charAt(this.index + 1) : false;
  };

  Lexer.prototype.readNumber_ = function() {
    var number = '';
    while (this.index < this.text.length) {
      var ch = this.text.charAt(this.index);
      if (ch === '.' || this.isNumber_(ch)) {
        number += ch;
      } else {
        break;
      }
      this.index++;
    }

    this.tokens.push({
      text: number,
      value: Number(number)
    });
  };

  Lexer.prototype.readString_ = function() {
    var textStartChar = this.text.charAt(this.index++);
    var string = '';
    while (this.index < this.text.length) {
      var ch = this.text.charAt(this.index++);

      if (ch === textStartChar) {
        break;
      } else {
        string += ch;
      }
    }

    this.tokens.push({
      text: string,
      value: string
    });
  };

  Lexer.prototype.readIdentifier_ = function() {
    var text = '';

    while (this.index < this.text.length) {
      var ch = this.text.charAt(this.index);
      if (this.isIdentifier_(ch) || this.isNumber_(ch)) {
        text += ch;
      } else {
        break;
      }
      this.index++;
    }

    this.tokens.push({
      text: text,
      identifier: true
    });
  };

  Lexer.prototype.isNumber_ = function(char) {
    return char >= '0' && char <= '9';
  };

  Lexer.prototype.isString_ = function(char) {
    return char === '\'' || char === '\"';
  };

  Lexer.prototype.isIdentifier_ = function(char) {
    return (char >= 'a' && char <= 'z') ||
           (char >= 'A' && char <= 'Z') ||
           char === '_' || char === '$';
  };

  Lexer.prototype.isWhitespace_ = function(char) {
    return char === ' ' || char === '\r' || char === '\t' ||
        char === '\n' || char === '\v';
  };

  /**
   * The AST Builder takes the array of tokens generated by the lexer, and builds up an Abstract Syntax Tree (AST) from them
   */
  function AST(lexer) {
    this.lexer_ = lexer;
  }
  AST.Program = 'Program';
  AST.Literal = 'Literal';
  AST.Array = 'Array';
  AST.Object = 'Object';
  AST.Identifier = 'Identifier';

  AST.prototype.constants = {
    'null': {type: AST.Literal, value: null},
    'true': {type: AST.Literal, value: true},
    'false': {type: AST.Literal, value: false}
  };

  AST.prototype.ast = function(text) {
    this.tokens = this.lexer_.lex(text);
    return this.program_();
  };

  AST.prototype.program_ = function() {
    var token = this.readToken_();
    return {
      type: AST.Program,
      body: this.processToken_(token)
    };
  };

  AST.prototype.readToken_ = function() {
    if (this.tokens.length > 0) {
      return this.tokens.shift();
    }
  };

  AST.prototype.processToken_ = function(token) {
    if (token.text === '[') {
      return this.arrayDeclaration_();
    } else if (token.text === '{') {
      return this.objectDeclaration_();
    } else if (this.constants.hasOwnProperty(token.text)) {
      return this.constants[token.text];
    } else if (token.identifier) {
      return this.identifier_(token);
    } else {
      return this.constant_(token);
    }
  };

  AST.prototype.constant_ = function(token) {
    return {
      type: AST.Literal,
      value: token.value
    };
  };

  AST.prototype.objectDeclaration_ = function() {
    var properties = [];
    var token = this.readToken_();
    while (token.text !== '}') {
      if (token.text === ',') {
        token = this.readToken_();
      }
      var key = token.text;
      this.readToken_();
      token = this.readToken_();
      properties.push({
        key: {
          type: AST.Identifier,
          value: key
        },
        value: this.processToken_(token)
      });
      token = this.readToken_();
    }
    return {
      type: AST.Object,
      properties: properties
    };
  };

  AST.prototype.arrayDeclaration_ = function() {
    var elements = [];
    var token = this.readToken_();

    while (token.text !== ']') {
      if (token.text !== ',') {
        elements.push(this.processToken_(token));
      }
      token = this.readToken_();
    }
    return {
      type: AST.Array,
      elements: elements
    };
  };

  AST.prototype.identifier_ = function(token) {
    return {
      type: AST.Identifier,
      value: token.text
    };
  };

  /**
   * The AST Compiler takes the abstract syntax tree and compiles it into a JavaScript function that evaluates the expression represented in the tree.
   */
  function ASTCompiler(ast) {
    this.ast_ = ast;
  }
  ASTCompiler.prototype.compile = function(text) {
    var ast = this.ast_.ast(text);
    this.state = {body: []};
    this.recurse(ast);
    return new Function('scope', this.state.body.join('')); // eslint-disable-line no-new-func
  };

  ASTCompiler.prototype.recurse = function(ast) {
    switch (ast.type) {
      case AST.Program:
        this.state.body.push('return ', this.recurse(ast.body), ';');
        break;
      case AST.Literal:
        return this.escape_(ast.value);
      case AST.Object:
        var properties = ast.properties.map(function(prop) {
          return this.escape_(prop.key.value) + ':' + this.recurse(prop.value);
        }.bind(this));
        return '{' + properties.join(',') + '}';
      case AST.Array:
        var elements = ast.elements.map(function(el) {
          return this.recurse(el);
        }.bind(this));
        return '[' + elements.join(',') + ']';
      case AST.Identifier:
        return 'scope' + '.' + ast.value;
    }
  };

  ASTCompiler.prototype.escape_ = function(value) {
    if (typeof value === 'string') {
      return '\'' + value + '\'';
    } else if (value === null) {
      return 'null';
    }
    return value;
  };

  /**
   * The Parser is responsible for combining the low-level steps mentioned above.
   */
  function Parse() {
    var lexer = new Lexer();
    var ast = new AST(lexer);
    this.astCompiler = new ASTCompiler(ast);
  }
  Parse.prototype.parse = function(expr) {
    return this.astCompiler.compile(expr);
  };

  return Parse;
}());
